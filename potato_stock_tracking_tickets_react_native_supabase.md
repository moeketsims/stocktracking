# Potato Stock Tracking Platform (Mobile-First)
## Ticket Backlog (React Native + Expo + Supabase + Docker)

Version: 1.0 (Jan 2026)  
Scope: 5 shops in a zone + 1 warehouse (optional but supported)  
Primary risk: potato supply availability + running out during trading hours

---

## 1) Product Summary

### 1.1 Problem statement
The franchise experiences recurring potato stock-outs due to incomplete visibility of (a) what has arrived, (b) what has been used, (c) what is held at shop level vs warehouse level, and (d) whether suppliers have stock when procurement is needed. Stock movements are often recorded inconsistently, causing late replenishment, emergency runs, and lost sales. The platform must provide a fast and reliable way to record receipts and usage, compute current on-hand stock per location, and forecast “days of cover” to trigger timely replenishment actions.

### 1.2 Primary users
- Shop staff (receiving + issuing/using stock during prep/service)
- Shop manager (approves adjustments, views shop-level dashboard)
- Zone manager (monitors 5 shops + warehouse, reallocates stock)
- Warehouse staff (receiving, dispatching to shops)
- Admin (user management, item catalog, thresholds)

### 1.3 Outcomes / capabilities
- Accurate on-hand potato stock per shop and warehouse (near real-time)
- Standardised stock transactions (receive, issue/use, transfer, waste, adjustment)
- Forecasted reorder dates using average usage and lead time
- Alerts to avoid stock-outs (low stock, projected stock-out date, supplier risk)
- Audit trails for accountability (who recorded what, when, from where)
- Multi-shop visibility with role-based access control

---

## 2) Recommended Tech Stack (Chosen)

### 2.1 Mobile
- React Native (Expo) + TypeScript
- React Query for server state caching
- Zustand for local UI state
- Zod + React Hook Form for validation
- On-device storage: SQLite (Expo SQLite) for offline-first transaction queue

### 2.2 Backend (Local Dev + Production)
- Supabase (Postgres, Auth, Storage, Realtime, Edge Functions if needed)
- Supabase local stack via Docker (Supabase CLI)
- Row Level Security (RLS) for tenant-like access by shop/zone/role

### 2.3 DevOps / Tooling
- Docker Desktop required for local Supabase
- GitHub Actions CI (lint, typecheck, tests)
- EAS Build for mobile builds (optional early; recommended later)

---

## 3) High-level Architecture (Mobile-first)

- Mobile app authenticates via Supabase Auth
- Transactions written to Postgres tables (stock_transactions)
- Stock balances computed by:
  - Option A: database view/materialized view, or
  - Option B: a ledger approach with server-side function to compute balance
- Forecast service computes:
  - rolling average usage per shop
  - days-of-cover and expected stock-out date
- Alerts are generated by:
  - scheduled job (Supabase cron / Edge function) OR app-side checks for v1
- Offline-first:
  - mobile queues transactions locally
  - syncs when online; conflict rules enforced server-side

---

## 4) Data Model (Core)

### Entities
- zones (id, name)
- locations (id, zone_id, type: shop|warehouse, name)
- items (id, sku, name, unit: kg|bag, conversion rules)
- suppliers (id, name, contact fields)
- item_suppliers (item_id, supplier_id, lead_time_days, min_order_qty)
- users (handled by Supabase Auth) + profiles (user_id, role, zone_id, location_id nullable)
- stock_transactions (id, created_at, created_by, location_id_from, location_id_to, item_id, qty, unit, type, notes, metadata)
  - type ∈ receive|issue|transfer|waste|adjustment
- stock_balance (view) derived from transactions
- reorder_policies (location_id, item_id, safety_stock_qty, reorder_point_qty, preferred_supplier_id)
- usage_metrics (optional table) for cached aggregates per day/week

### Notes
- Potatoes can be tracked in bags or kg. Provide a conversion (e.g., 1 bag = 10kg) configurable per supplier/item if needed.
- “Issue/use” can be recorded as:
  - daily totals (fast v1), or
  - event-driven per batch (v2)

---

## 5) Definition of Done (Global)
A ticket is done when:
- Code is merged to main with passing CI (lint, typecheck, tests as applicable)
- Acceptance criteria met and demoable in Expo on a physical device (or emulator)
- Minimal logs/auditing exist for core actions
- Database migrations and RLS policies applied in local Supabase

---

# 6) Backlog Structure
- EPIC A: Foundations (Repo, Supabase local, auth, navigation)
- EPIC B: Core Stock Ledger (transactions + balance)
- EPIC C: Forecasting + Alerts
- EPIC D: Warehouse + Transfers
- EPIC E: Analytics + Reporting
- EPIC F: Admin + Governance (roles, policies, audit)
- EPIC G: Quality (tests, CI, security review, rollout)

Each ticket includes a **Vibe-coding Prompt** you can paste into your coding assistant.

---

## EPIC A — Foundations (Week 1)

### A1 — Monorepo setup (Mobile + Backend config)
**Goal:** Create repo structure, tooling, and conventions.

**Acceptance criteria**
- Repo contains `/apps/mobile` and `/infra/supabase`
- TypeScript, linting, formatting configured
- Basic README with local dev steps

**Implementation tasks**
- Create folder structure
- Configure ESLint + Prettier
- Add `.editorconfig`, `.nvmrc` (optional), basic scripts

**Vibe-coding prompt**
> Create a monorepo folder structure with `apps/mobile` (Expo + TypeScript) and `infra/supabase` for local Supabase. Add ESLint + Prettier for TS/TSX, basic scripts (`lint`, `typecheck`, `format`) at root, and a README explaining how to run mobile and Supabase locally.

---

### A2 — Supabase local environment via Docker (Supabase CLI)
**Goal:** A reproducible local backend with migrations and seed data.

**Acceptance criteria**
- `supabase start` boots Postgres/Auth/Storage locally via Docker
- Migrations folder present
- Seed script populates demo zone, 5 shops, 1 warehouse, potato item

**Implementation tasks**
- Install/configure Supabase CLI instructions
- Initialize supabase project in `/infra/supabase`
- Add seed SQL

**Vibe-coding prompt**
> Set up Supabase local in `/infra/supabase` using Supabase CLI so it runs via Docker. Include initial SQL migration files and a seed script creating: 1 zone, 5 shop locations, 1 warehouse location, 1 potato item, and default reorder policy per location.

---

### A3 — Database schema v1 (tables + indexes)
**Goal:** Implement core tables for zones, locations, items, profiles, transactions, reorder policies.

**Acceptance criteria**
- Migrations create all tables and indexes
- Constraints enforce valid transaction types and positive quantities where appropriate

**Vibe-coding prompt**
> Write Supabase SQL migrations for the v1 schema: zones, locations, items, suppliers, item_suppliers, profiles, stock_transactions, reorder_policies. Include indexes on (location_id, item_id, created_at) for transactions and enforce transaction type enum and non-zero qty.

---

### A4 — Auth + Profiles + Roles (RLS baseline)
**Goal:** Auth works, users have roles, RLS restricts data.

**Roles**
- admin: all zones/locations
- zone_manager: all locations in zone
- location_manager: one location
- staff: one location

**Acceptance criteria**
- Users can sign in
- Profiles table stores role + zone/location
- RLS restricts read/write accordingly for locations and transactions

**Vibe-coding prompt**
> Implement Supabase Auth + a `profiles` table linked to `auth.users`. Add RLS policies so staff/location_manager can only see/write transactions for their assigned location; zone_manager can see/write for all locations in their zone; admin can do all. Provide example policies and a helper SQL function to fetch the user’s profile claims.

---

### A5 — Expo app shell (navigation + auth screens)
**Goal:** Mobile app runs, login works, role-aware navigation exists.

**Acceptance criteria**
- Login screen, logout, persistent session
- After login, user lands on a dashboard
- Navigation structure prepared for modules (Stock, Receive, Transfers, Alerts, Reports, Settings)

**Vibe-coding prompt**
> Create an Expo + TypeScript app with authentication using Supabase client. Implement Login and a basic authenticated layout with bottom tabs: Dashboard, Stock, Transactions, Alerts, Settings. Persist session and handle sign-out.

---

## EPIC B — Core Stock Ledger (Weeks 2–3)

### B1 — Items + Units (potatoes first, extensible later)
**Goal:** Item catalog supports potato tracking in bags/kg.

**Acceptance criteria**
- Potato item exists (seeded)
- UI shows item list (potato at minimum)
- Unit conversion supported (configurable)

**Vibe-coding prompt**
> Implement item listing in the mobile app (starting with potatoes). Add unit selection (kg/bag) with a configurable conversion factor per item. Ensure transaction entry normalizes qty into a canonical unit for storage (e.g., kg).

---

### B2 — Receive stock (GRV-style) flow
**Goal:** Staff record deliveries quickly and consistently.

**Acceptance criteria**
- Receive form: item, qty, unit, supplier, optional photo/notes
- Creates `receive` transaction with location_id_to = current location
- Updates balance view reflects the receive

**Vibe-coding prompt**
> Build a “Receive Stock” screen: select item (potatoes), enter quantity and unit, pick supplier, add optional notes. On submit create a `stock_transactions` row with type `receive`, `location_id_to` = user’s location, and store normalized qty. Show a success confirmation and updated on-hand balance.

---

### B3 — Issue/use stock (daily usage entry)
**Goal:** Track how much stock was consumed by the shop.

**Acceptance criteria**
- Issue form: item, qty, unit, usage date, notes
- Creates `issue` transaction with location_id_from = current location
- Basic guardrails (cannot issue negative; warn if would go below zero)

**Vibe-coding prompt**
> Build an “Issue/Use Stock” screen to record daily potato usage. Save as `stock_transactions` type `issue` with `location_id_from` = user’s location. Implement a pre-submit check that fetches current balance and warns if the issue would push balance below zero (allow override for managers).

---

### B4 — Adjustments + Waste
**Goal:** Correct errors and record wastage separately.

**Acceptance criteria**
- Waste flow records spoiled/trim loss
- Adjustment flow requires reason and manager approval (role-based)

**Vibe-coding prompt**
> Add two transaction flows: Waste (type `waste`) and Adjustment (type `adjustment`). Waste is available to staff with a reason; Adjustment requires role ≥ location_manager and must include a reason code and free-text note.

---

### B5 — Stock balance computation (DB view + API)
**Goal:** App shows current on-hand per location.

**Acceptance criteria**
- A `stock_balance` view returns on_hand_qty per (location, item)
- App dashboard shows potato balance clearly
- Balance updates after each transaction (re-fetch / realtime optional)

**Vibe-coding prompt**
> Create a SQL view `stock_balance` that computes on-hand qty per location and item from the transactions ledger (receives add, issues/waste subtract, transfers subtract from from-location and add to to-location, adjustments add/subtract). Expose it via Supabase and render it on the dashboard and Stock tab.

---

### B6 — Transaction history + audit trail
**Goal:** A searchable ledger for accountability.

**Acceptance criteria**
- List view with filters: type, date range, item, location (role-based)
- Detail view shows who recorded it and notes

**Vibe-coding prompt**
> Implement a Transactions screen that lists recent `stock_transactions` with filters and a detail view. Include created_by, created_at, type, qty, unit, item, locations, and notes. Ensure staff only see their location; managers see broader scope via RLS.

---

### B7 — Offline-first transaction queue (v1)
**Goal:** App still works when connectivity is poor.

**Acceptance criteria**
- When offline, transactions are queued locally
- When online, queued transactions sync automatically
- User sees sync status and errors

**Vibe-coding prompt**
> Add offline support: if Supabase request fails due to network, store the transaction payload in a local SQLite queue with status=queued. Implement a background sync loop that retries when network is available. Show a badge “Queued: N” and allow manual retry.

---

## EPIC C — Forecasting + Alerts (Weeks 3–4)

### C1 — Usage rate (rolling average)
**Goal:** Compute typical daily potato usage per shop.

**Acceptance criteria**
- Rolling average usage (7-day default) computed from issue transactions
- Works per location
- Visible on dashboard

**Vibe-coding prompt**
> Compute a rolling 7-day average daily usage for potatoes per location from `issue` transactions. Implement as a SQL view or RPC function. Display “Avg daily usage” on the dashboard.

---

### C2 — Days of cover + projected stock-out date
**Goal:** Translate stock into time remaining.

**Acceptance criteria**
- Days of cover = on_hand / avg_daily_usage (handle divide-by-zero)
- Stock-out date shown as calendar date
- Accuracy validated with test data

**Vibe-coding prompt**
> Add “Days of cover” and “Projected stock-out date” for potatoes per location using current on-hand from `stock_balance` and rolling average usage. Handle edge cases (no usage data). Render it clearly on dashboard.

---

### C3 — Reorder policy + lead time
**Goal:** Decide when to reorder.

**Acceptance criteria**
- Reorder point based on safety stock + lead time usage
- Configurable per location (default seeded)
- Suggest reorder date and reorder qty

**Vibe-coding prompt**
> Implement reorder policies per location for potatoes: safety_stock_qty and preferred supplier lead_time_days. Compute reorder point = safety_stock_qty + (avg_daily_usage * lead_time_days). If on_hand <= reorder_point, flag “Reorder now” and suggest reorder quantity to reach target days (e.g., 7 days).

---

### C4 — Alerts (in-app)
**Goal:** Avoid surprises.

**Acceptance criteria**
- Alerts list includes: low stock, reorder now, supplier risk (manual flag)
- Alerts can be acknowledged by manager
- Alerts are role-scoped

**Vibe-coding prompt**
> Build an Alerts screen that shows computed alerts for each location (scoped by role). Include: Low stock (below safety), Reorder now (below reorder point), and Supplier risk (manual toggle). Add acknowledge action that writes an `alerts_ack` record.

---

## EPIC D — Warehouse + Transfers (Weeks 4–5)

### D1 — Warehouse location support
**Goal:** Warehouse stock visible like shops.

**Acceptance criteria**
- Warehouse appears as a location
- Warehouse staff can receive stock into warehouse
- Zone manager can view warehouse balance

**Vibe-coding prompt**
> Extend the app so warehouse is just another location type. Ensure warehouse staff role is supported (location-scoped) and can receive potatoes into warehouse and view its balance.

---

### D2 — Transfers (warehouse ↔ shops, shop ↔ shop)
**Goal:** Record stock movements to prevent “ghost stock.”

**Acceptance criteria**
- Transfer flow: from location, to location, qty, unit, notes
- Creates one transfer transaction referencing both locations
- On-hand updates for both ends

**Vibe-coding prompt**
> Implement a Transfer screen for managers: choose from-location and to-location (limited by role scope), enter qty and unit, submit a `transfer` transaction with both location_id_from and location_id_to. Verify balance reduces at from-location and increases at to-location via the `stock_balance` view.

---

### D3 — Reallocation suggestions
**Goal:** Use zone visibility to shift stock intelligently.

**Acceptance criteria**
- Shows which shop has excess vs which will stock-out soon
- Suggest transfer qty based on days-of-cover targets

**Vibe-coding prompt**
> Create a “Reallocation” view for zone managers that compares days-of-cover across shops. Identify shops below 2 days and shops above 6 days and suggest a transfer quantity to bring both closer to a target (e.g., 4 days).

---

## EPIC E — Analytics + Reporting (Weeks 5–6)

### E1 — Daily summary (receive/issue/waste) per location
**Acceptance criteria**
- Simple daily table and totals
- Exportable CSV (optional v1)

**Vibe-coding prompt**
> Build a Reports screen that shows daily totals per location for receives, issues, waste, and net change for potatoes. Allow date selection and show totals. Add a basic CSV export if easy.

---

### E2 — Variance report (expected vs actual usage)
**Acceptance criteria**
- Expected usage based on rolling average
- Actual usage from issues
- Flags anomalies

**Vibe-coding prompt**
> Implement a variance report: for each day and location, compare actual issue qty to expected (rolling avg) and flag if deviation exceeds a threshold (e.g., ±25%). Display anomalies for manager review.

---

## EPIC F — Admin + Governance (Weeks 6–7)

### F1 — Admin console (basic, can be web later)
**Acceptance criteria**
- Manage locations, items, suppliers, reorder policies
- Role assignments via profiles

**Vibe-coding prompt**
> Add an Admin section (only for admin role) to manage locations, suppliers, and reorder policies for potatoes. Implement CRUD screens with validation and RLS enforcement.

---

### F2 — Audit log hardening
**Acceptance criteria**
- Immutable logging for critical actions
- Adjustment approvals captured

**Vibe-coding prompt**
> Add an immutable audit log table capturing action_type, actor, timestamp, entity references, and before/after snapshots for sensitive actions (adjustments, policy changes, role changes). Ensure only admin can read full logs.

---

## EPIC G — Quality + Rollout (Weeks 7–8)

### G1 — Automated tests (smoke + critical workflows)
**Acceptance criteria**
- Tests for: login, receive, issue, transfer, balance view correctness (lightweight)
- CI runs on PRs

**Vibe-coding prompt**
> Add lightweight automated tests. For mobile: component tests for forms and a mock Supabase client. For backend: SQL-level tests verifying balance computations. Configure GitHub Actions to run lint, typecheck, and tests on PR.

---

### G2 — Security review (RLS + permissions)
**Acceptance criteria**
- RLS policies reviewed and validated with test users
- No cross-location data leakage

**Vibe-coding prompt**
> Create a security checklist and write automated RLS validation queries. Test with four users: staff (shop A), manager (shop A), zone_manager (zone), admin. Verify each can only read/write intended records.

---

### G3 — Deployment + environments (dev/staging/prod)
**Acceptance criteria**
- Separate Supabase projects or schemas per environment
- App config supports switching environments
- Basic backup strategy documented

**Vibe-coding prompt**
> Define dev/staging/prod environment setup for Supabase and the mobile app. Add environment variable support in Expo and document how to point the app to each environment. Provide a simple backup and restore approach for Postgres.

---

## 7) Suggested Delivery Plan (Practical)
- Week 1: EPIC A (foundation)
- Weeks 2–3: EPIC B (ledger + balances + offline queue)
- Week 4: EPIC C (forecast + alerts)
- Week 5: EPIC D (warehouse + transfers)
- Week 6: EPIC E (reports)
- Week 7: EPIC F (admin + audit)
- Week 8: EPIC G (QA + deployment) and pilot rollout

---

## 8) MVP Checklist (Go-Live Minimum)
- Auth + roles + RLS correct
- Receive + Issue + Transfer workflows working for potatoes
- Accurate on-hand balance per location
- Forecast: days of cover + reorder now
- Alerts screen
- Transaction history
- Offline queue for transactions
- Basic reporting: daily summary

---

## 9) Nice-to-haves (Phase 2)
- Barcode scanning for bags (if suppliers support labels)
- Supplier integration (availability reporting, order placement)
- Cost tracking (purchase price, wastage cost, margin analytics)
- Multi-item expansion beyond potatoes (oil, batter, packaging)
- POS integration for usage estimation (sales → expected usage)

